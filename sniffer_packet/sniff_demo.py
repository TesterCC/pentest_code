# coding=utf-8
"""
DATE:   2021/8/9
AUTHOR: TesterCC
"""

# 抓包 sniffer packet; 发包forward packet
# ref: https://cloud.tencent.com/developer/article/1694737
# https://blog.csdn.net/GFS_lele/article/details/105132287

from scapy.all import *


def pack_callback(packet):
    # print(packet.show())
    # packet.display()  # 这个是优化为可度的展示
    # print(packet.haslayer('Ether'))  # True or False
    if packet.haslayer('Ethernet'):
        print(
            f"Ethernet Info: {packet['Ethernet'].src} -> {packet['Ethernet'].dst}, type is {packet['Ethernet'].type} ")

    if packet.haslayer('IP'):
        print(f"IP Info: {packet['IP'].src} -> {packet['IP'].dst}")
        print(f"protol is : {packet['IP'].proto}")
        print(f"ttl is : {packet['IP'].ttl}")

    if packet.haslayer('TCP'):
        print(f"TCP INfo: {packet['TCP'].sport} -> {packet['TCP'].dport}")

    if packet.haslayer('UDP'):
        print(f"UDP Info: {packet['UDP'].sport} -> {packet['UDP'].dport}")
        print(f"len: {packet['UDP'].len}")

    if packet.haslayer('ARP'):
        print(f"ARP Info: {packet['ARP'].psrc} -> {packet['ARP'].pdst}")
        print(f"ARP Info: {packet['ARP'].hwsrc} -> {packet['ARP'].hwdst}")


'''
　　count：抓包的数量，0表示无限制；
　　store：保存抓取的数据包或者丢弃，1保存，0丢弃
　　offline：从 pcap 文件读取数据包，而不进行嗅探，默认为None
　　prn：为每一个数据包定义一个函数，如果返回了什么，则显示。例如：prn = lambda x: x.summary()；（packct.summar()函数返回的是对包的统计性信息）
　　filter：过滤规则，使用wireshark里面的过滤语法
　　L2socket：使用给定的 L2socket
　　timeout：在给定的时间后停止嗅探，默认为 None
　　opened_socket：对指定的对象使用 .recv() 进行读取；
　　stop_filter：定义一个函数，决定在抓到指定数据包后停止抓包，如：stop_filter = lambda x: x.haslayer(TCP)；
　　iface：指定抓包的接口
'''

sniff(prn=pack_callback, iface='ens33', count=0)

# -*- coding: utf-8 -*-
# @Time    : 2022/12/4
# @Author  : SecCodeCat

# File Client
from optparse import OptionParser
from socket import *
import json
import os
import sys
import struct


def recv_file(head_dir, tcp_client):
    filename = head_dir['filename']
    filezise = head_dir['filesize_bytes']
    print(f"[+]filename: {filename[0]}")
    print(f"[+]filesize: {filezise}")
    recv_len = 0
    f = open(filename[0], 'wb')
    while recv_len < filezise:
        if filezise > 1024:
            recv_msg = tcp_client.recv(1024)
            recv_len += len(recv_msg)
            f.write(recv_msg)
        else:
            recv_msg = tcp_client.recv(filezise)
            recv_len += len(recv_msg)
            f.write(recv_msg)
    f.close()
    print(f"[+] Finish receive file!")


def main():
    parser = OptionParser("Usage:%prog -u <target address> -p <port>")
    parser.add_option('-u', type='string', dest='ip', help='specify target ip')
    parser.add_option('-p', type='string', dest='port', help='specify target port')
    options, args = parser.parse_args()

    target_ip = options.ip
    target_port = int(options.port)

    # init sockt
    tcp_client = socket(AF_INET, SOCK_STREAM)
    ip_port = (target_ip, target_port)
    tcp_client.connect_ex(ip_port)  # connect()函数的扩展版本，出错时返回出错码，而不是抛出异常。
    print("[+] waiting server response data ...")
    struct_len = tcp_client.recv(4)  # 接收报头长度
    struct_info_len = struct.unpack('i', struct_len)[0]  # 解析得到报头信息的长度
    print(f"[+] receive header length: {struct_info_len}")
    head_info = tcp_client.recv(struct_info_len)
    head_dir = json.loads(head_info.decode("utf-8"))  # 将报头内容反序列化
    print(f"[+] output header content: {head_dir}")
    recv_file(head_dir, tcp_client)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("[E] Interrupted by user ...")

#!/usr/bin/env python3
"""Demo FTP fuzzer as a standalone script."""
import re
import time

from boofuzz import *


# install vsftpd on kali for verify

class BooFtpException(Exception):
    pass


count = 0


def session_pre_send_callback(target, fuzz_data_logger, session, *args, **kwargs):
    pre_time = round(time.time() * 1000)
    session.fuzz_node.names["pre_time"] = pre_time
    session.fuzz_node.names["fix_status"] = 1
    print(f"[DDD] pre_time: {pre_time}")
    # session.fuzz_node.names["pre_time"]._value = f"{pre_time}"
    return session.fuzz_node.render()


# def check_reply_code_light(target, fuzz_data_logger, session, test_case_context, *args, **kwargs):
def check_reply_code_light(target, fuzz_data_logger, session, test_case_context, *args, **kwargs):
    """
        Args:
            target (Target): Target with sock-like interface.
            fuzz_data_logger (ifuzz_logger.IFuzzLogger): Allows logging of test checks and passes/failures.
                Provided with a test case and test step already opened.
            session (Session): Session object calling post_send.
                Useful properties include last_send and last_recv.
            test_case_context (ProtocolSession): Context for test case-scoped data.
                :py:class:`TestCaseContext` :py:attr:`session_variables <TestCaseContext.session_variables>`
                values are generally set within a callback and referenced in elements via default values of type
                :py:class:`ReferenceValueTestCaseSession`.
            args: Implementations should include \\*args and \\**kwargs for forward-compatibility.
            kwargs: Implementations should include \\*args and \\**kwargs for forward-compatibility.
    """

    # print(session.root.id)  # 0
    # print(session.root.label)  # __ROOT_NODE__
    # print(session.fuzz_node)
    # print(dir(session.fuzz_node.names))
    # print(type(session.fuzz_node.names))
    print(f"[post_send] pre_time: {session.fuzz_node.names['pre_time']}")

    # print(dir(test_case_context.previous_message))
    # print(test_case_context.previous_message.id, test_case_context.previous_message.label)
    print(f"[D] testcase count: {fuzz_data_logger.test_case_count}")
    # print(dir(test_case_context.current_message))
    print(test_case_context.current_message.id, test_case_context.current_message.label,
          test_case_context.current_message.name)

    # print(f"[Debug] test_case_context.session_variables: {test_case_context.session_variables}")  # {}

    print("x" * 66)
    fuzz_data_logger.log_info(session.last_send)
    print("-" * 66)
    recv_data = session.last_recv
    fuzz_data_logger.log_info(recv_data)
    print("=" * 66)

    if recv_data:
        print(f"[Debug] Received data: {recv_data}")
        print("*" * 99)


def check_reply_code(target, fuzz_data_logger, session, test_case_context, *args, **kwargs):
    """
        Args:
            target (Target): Target with sock-like interface.
            fuzz_data_logger (ifuzz_logger.IFuzzLogger): Allows logging of test checks and passes/failures.
                Provided with a test case and test step already opened.
            session (Session): Session object calling post_send.
                Useful properties include last_send and last_recv.
            test_case_context (ProtocolSession): Context for test case-scoped data.
                :py:class:`TestCaseContext` :py:attr:`session_variables <TestCaseContext.session_variables>`
                values are generally set within a callback and referenced in elements via default values of type
                :py:class:`ReferenceValueTestCaseSession`.
            args: Implementations should include \\*args and \\**kwargs for forward-compatibility.
            kwargs: Implementations should include \\*args and \\**kwargs for forward-compatibility.
    """
    print(dir(target))
    print(dir(fuzz_data_logger))
    print(dir(session))

    # print(session.root.id)  # 0
    # print(session.root.label)  # __ROOT_NODE__
    # print(session.root.name)
    # print(session.root.number)
    # print("--------------~~~~~~~~~~~~~~")
    # print(test_case_context)
    # print(dir(test_case_context))

    # print(dir(test_case_context.previous_message))
    # print(test_case_context.previous_message.id, test_case_context.previous_message.label)

    # print(dir(test_case_context.current_message))
    # print(test_case_context.current_message.id, test_case_context.current_message.label)

    # print(f">>>>> REAL RECEIVED: {target.recv(2048)}")
    # print(f'[D0] debug >>>> {test_case_context.session_variables}')

    # global count
    # count += 1
    # # print(count)
    # test_case_context.session_variables['count'] = count
    # test_case_context.session_variables['time'] = int(time.time())
    # print(f'[D] check_reply_code after update: {test_case_context.session_variables}')
    # # fuzz_data_logger.log_info(test_case_context.session_variables)

    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")

    if test_case_context.previous_message.name == "__ROOT_NODE__":
        # print("[DD1]", test_case_context.session_variables)
        # return
        pass
    else:

        try:
            fuzz_data_logger.log_info("[>>>>>]Parsing reply contents: {0}".format(session.last_recv))
            # just parse info
            ret_code = parse_ftp_reply(session.last_recv)
            print(f"[>>>>>] {ret_code}")

            if ret_code == "230":
                test_case_context.session_variables['ftp_login_status'] = 1
                print("[DD1]", test_case_context.session_variables)
        except BooFtpException as e:
            fuzz_data_logger.log_fail(str(e))
        fuzz_data_logger.log_pass()
        print("[DD2]", test_case_context.session_variables)


def parse_ftp_reply(data):
    """
    Parse FTP reply and return reply code. Raise BooFtpException if reply is invalid.

    Note:
    1. Multi-line replies not supported yet

    RFC 959 excerpt:
          A reply is defined to contain the 3-digit code, followed by Space
          <SP>, followed by one line of text (where some maximum line length
          has been specified), and terminated by the Telnet end-of-line
          code.  There will be cases however, where the text is longer than
          a single line...

    Args:
        data (bytes): Raw reply data
    """
    reply_code_len = 3

    if len(data) < reply_code_len:
        raise BooFtpException("Invalid FTP reply, too short; must be a 3-digit sequence followed by a space")
    else:
        try:
            reply = data[0:reply_code_len + 1].decode('ascii')
            # reply = data[0:reply_code_len + 1]
            print(f"[D] replay: {reply}")
            # print(type(reply[0:reply_code_len]))
            print(reply[0:reply_code_len])
        except ValueError:
            raise BooFtpException(
                "Invalid FTP reply, non-ASCII characters; must be a 3-digit sequence followed by a space")
        # if not re.match('[1-5][0-9][0-9] ', reply[0:4]):
        #     raise BooFtpException("Invalid FTP reply; must be a 3-digit sequence followed by a space")

        return reply[0:reply_code_len]


def resp_all(target, fuzz_data_logger, session, test_case_context, *args, **kwargs):
    print(session.root.id)  # 0
    print(session.root.label)  # __ROOT_NODE__
    # print(session.root.name)
    # print(session.root.number)

    print(f'[D00] {test_case_context.session_variables}')

    # print(dir(test_case_context))
    # fuzz_data_logger.log_info(test_case_context.previous_message.name)

    print('~' * 99)

    try:
        # print(target.recv(1024).decode())
        print("=" * 66)
        # fuzz_data_logger.log_info(session.last_send)
        print("=" * 66)
        fuzz_data_logger.log_info(session.last_recv)
        if "230" in session.last_recv:
            print("[D] >>>> login success ...")

        # if 'redirectionURL' in target.recv(10240).decode():
        #     fuzz_data_logger.log_check(session.last_send)
    except:
        fuzz_data_logger.log_fail("Unable to connect ...")
        return

    print('--' * 66)


def main():
    """
    This example is a very simple FTP fuzzer. It uses no process monitory
    (procmon) and assumes that the FTP server is already running.
    """
    session = Session(target=Target(connection=TCPSocketConnection("172.16.16.133", 21)),
                      receive_data_after_fuzz=True,
                      pre_send_callbacks=[session_pre_send_callback],
                      sleep_time=1
                      )

    # define_proto_static(session=session)
    # define_proto(session=session)
    define_ftp_static(session=session)

    session.fuzz(max_depth=1)


def define_ftp_static(session):
    """Same protocol, using the static definition style."""
    s_initialize("user1")
    s_string("USER", fuzzable=False)
    s_delim(" ", fuzzable=False)
    s_string("ftpuser", fuzzable=False)
    s_static("\r\n")

    s_initialize("pass1")
    s_string("PASS", fuzzable=False)
    s_delim(" ", fuzzable=False)
    s_string("1234567")
    s_static("\r\n")

    s_initialize("cwd1")
    s_string("CWD", fuzzable=False)
    s_delim(" ", fuzzable=False)
    s_string("/home/ftpuser")
    s_static("\r\n")

    # s_random("\x00", 1, 1) # for test

    session.connect(s_get("user1"), callback=check_reply_code_light)
    session.connect(s_get("user1"), s_get("pass1"), callback=check_reply_code_light)
    session.connect(s_get("pass1"), s_get("cwd1"))
    # session.connect(s_get("cwd1"), callback=resp_all)


# def define_proto(session):
#     # disable Black formatting to keep custom indentation
#     # fmt: off
#     user = Request("user", children=(
#         String(name="key", default_value="USER"),
#         Delim(name="space", default_value=" "),
#         String(name="val", default_value="anonymous"),
#         Static(name="end", default_value="\r\n"),
#     ))
#
#     passw = Request("pass", children=(
#         String(name="key", default_value="PASS"),
#         Delim(name="space", default_value=" "),
#         String(name="val", default_value="james"),
#         Static(name="end", default_value="\r\n"),
#     ))
#
#     stor = Request("stor", children=(
#         String(name="key", default_value="STOR"),
#         Delim(name="space", default_value=" "),
#         String(name="val", default_value="AAAA"),
#         Static(name="end", default_value="\r\n"),
#     ))
#
#     retr = Request("retr", children=(
#         String(name="key", default_value="RETR"),
#         Delim(name="space", default_value=" "),
#         String(name="val", default_value="AAAA"),
#         Static(name="end", default_value="\r\n"),
#     ))
#     # fmt: on
#
#     session.connect(user)
#     session.connect(user, passw)
#     session.connect(passw, stor)
#     session.connect(passw, retr)


# fuzz
# def define_proto_static(session):
#     """Same protocol, using the static definition style."""
#     s_initialize("user")
#     s_string("ftpuser")
#     s_delim(" ")
#     s_string("anonymous")
#     s_static("\r\n")
#
#     s_initialize("pass")
#     s_string("1234567")
#     s_delim(" ")
#     s_string("james")
#     s_static("\r\n")
#
#     # s_initialize("stor")
#     # s_string("STOR")
#     # s_delim(" ")
#     # s_string("AAAA")
#     # s_static("\r\n")
#     #
#     # s_initialize("retr")
#     # s_string("RETR")
#     # s_delim(" ")
#     # s_string("AAAA")
#     # s_static("\r\n")
#
#     # session.connect(s_get("user"))
#     session.connect(s_get("user"), callback=check_reply_code)
#     # session.connect(s_get("pass"), s_get("stor"))
#     # session.connect(s_get("pass"), s_get("retr"))


if __name__ == "__main__":
    main()

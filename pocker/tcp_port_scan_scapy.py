#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'MFC'
__time__ = '2020/6/15 20:59'

import sys
from scapy.all import *
# scapy库里有一个all.py文件，这一句就是把all.py文件里面所有函数和变量导入当前环境
from scapy.layers.inet import IP,TCP

"""
8-2 使用Python实现端口扫描

自己构建SYN包来进行发包和收包并判断，可用scapy模块
其实也可以直接用socket模块进行构造，不过socket模块构造TCP包比较复杂

pip install -i https://pypi.douban.com/simple/ scapy

python tcp_port_scan_scapy.py 123.59.41.57 22


SYN扫描：
使用SYN扫描的不同点就在于客户端收到SYN/ACK包响应后，客户端不返回ACK包响应（如果客户端返回ACK包就是表示连接已建立），而直接返回RST包响应请求端口链接（告诉服务端第三次握手失败），
这样三次握手就没有完成，但通过前2个包已经确定了端口是否开放了。这样就完成了端口的扫描又不会在目标系统日志中记录日志。
"""

def scan(ip, port):
    print(f'[+] Server {ip} , Port: {port} is scanning ')
    try:
        # import ipdb;ipdb.set_trace()    # ipdb是第三方包，也可以直接用pab   import pdb; pdb.set_trace()
        port = int(port)
        src_port = RandShort()  # 全局访问一个端口号 0 - 65535  flags="S" SYN
        res = sr1(IP(dst=ip)/TCP(sport=src_port,dport=port,flags="S"), timeout=7)  # 获取内容为空，要check一下
        if res.haslayer(TCP):
            if res.getlayer(TCP).flags == 'SA':   # SYN_ACK
                sr(IP(dst=ip)/TCP(sport=src_port,dport=port,flags="AR"),timeout=7)
                print('Result: OPEN')
            elif res.getlayer(TCP).flags == 'RA':   # RST
                print("Result: CLOSE")
    except:
        print("Scan error! Exiting...")


if __name__ == '__main__':
    ip = sys.argv[1]
    port = sys.argv[2]
    scan(ip, port)

# 要在命令行执行，执行语句为  python tcp_port_scan.py 220.181.38.148 22